---
layout: post
title: transaction
date: 2019-01-07
category: java
tags: [transaction]
description: learn transaction
---
#### 事务
 - A 原子性
 - C 一致性
 - I 隔离性
 - D 持久性

1. 单机事务（数据库）
 - 问题
   - 脏读
   - 不可重复读
   - 幻读
 - 隔离级别（问题解决方法）
   - 串行化     可避免脏读、不可重复读、幻读
   - 可重复读   可避免脏读、不可重复读            （mysql默认）
   - 读已提交   可避免脏读                        （oracle默认）
   - 读未提交   最低级别，任何情况都无法保证
 - 锁
   - 乐观锁、悲观锁
   - 行级锁、表级锁
2. 分布式事务
 - CAP
   - C 一致性（最终一致性、强一致性、弱一致性）
   - A 可用性
   - P 分区容错性
 - BASE 理论是对CAP中的一致性和可用性进行一个权衡的结果
   - Basically Available（基本可用）
   - Soft state（软状态）
   - Eventually consistent（最终一致性）
 - 2PC（两阶段提交） 又叫做XA Transactions
   - 第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.
   - 第二阶段：事务协调器要求每个数据库提交数据。
 - TCC（补偿事务）
   - Try 阶段主要是对业务系统做检测及资源预留
   - Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
   - Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。
 - 本地消息表（异步确保）
   - 生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。
   - 消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。
   - 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。
